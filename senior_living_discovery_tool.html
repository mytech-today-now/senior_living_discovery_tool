<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üè† Find Hidden Gems Near You!</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glassmorphism-ui/dist/glass.min.css">
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      background-color: #e0eafc;
      background-image: linear-gradient(315deg, #e0eafc 0%, #cfdef3 74%);
      color: #333;
      padding: 1rem;
    }

    /* Glass morphism base styles */
    .glass-card {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
      backdrop-filter: blur(8.5px);
      -webkit-backdrop-filter: blur(8.5px);
      border: 1px solid rgba(255, 255, 255, 0.18);
      padding: 2rem;
      margin: 1rem 0;
    }

    /* Glass morphism for all buttons */
    button, .download-btn {
      background: rgba(255, 255, 255, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      padding: 12px 24px;
      color: #333;
      font-weight: 600;
      cursor: pointer;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 4px 16px rgba(31, 38, 135, 0.2);
      transition: all 0.3s ease;
      font-size: 14px;
      margin: 8px 4px;
    }

    button:hover, .download-btn:hover {
      background: rgba(255, 255, 255, 0.35);
      box-shadow: 0 6px 20px rgba(31, 38, 135, 0.3);
      transform: translateY(-2px);
      border: 1px solid rgba(255, 255, 255, 0.4);
    }

    button:active, .download-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(31, 38, 135, 0.2);
    }

    /* Glass morphism for labels */
    label {
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 8px 12px;
      color: #333;
      font-weight: 600;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 2px 8px rgba(31, 38, 135, 0.15);
      display: inline-block;
      margin-bottom: 8px;
      font-size: 14px;
    }

    /* Glass morphism for input fields */
    input[type="file"], textarea, input[type="range"] {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      padding: 12px 16px;
      color: #333;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: inset 0 2px 8px rgba(31, 38, 135, 0.1);
      transition: all 0.3s ease;
      font-family: inherit;
      width: 100%;
      margin-top: 0.5rem;
      box-sizing: border-box;
    }

    input[type="file"]:focus, textarea:focus {
      outline: none;
      background: rgba(255, 255, 255, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.4);
      box-shadow: inset 0 2px 8px rgba(31, 38, 135, 0.15), 0 0 0 2px rgba(31, 38, 135, 0.1);
    }

    textarea::placeholder {
      color: rgba(51, 51, 51, 0.7);
    }

    /* Glass morphism for range slider */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 20px;
      outline: none;
      padding: 0;
      margin: 8px 0;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: rgba(255, 255, 255, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      cursor: pointer;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 2px 8px rgba(31, 38, 135, 0.3);
    }

    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: rgba(255, 255, 255, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(31, 38, 135, 0.3);
    }

    /* Glass morphism for score display */
    #scoreDisplay {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      padding: 6px 12px;
      color: #333;
      font-weight: 600;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 2px 8px rgba(31, 38, 135, 0.15);
      min-width: 30px;
      text-align: center;
    }

    #outputTable {
      overflow-x: scroll;
      max-height: 500px;
    }

    /* Glass morphism for table */
    table {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      border-collapse: separate;
      border-spacing: 0;
      overflow: hidden;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 4px 16px rgba(31, 38, 135, 0.2);
      width: 100%;
    }

    th, td {
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 12px;
      color: #333;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    th {
      background: rgba(255, 255, 255, 0.25);
      font-weight: 600;
      text-align: left;
    }

    .popup {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    .popup-content {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 16px;
      padding: 2rem;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.4);
    }

    .close-btn {
      float: right;
      cursor: pointer;
      font-weight: bold;
      font-size: 1.2rem;
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      transition: all 0.3s ease;
    }

    .close-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.1);
    }

    .high-score {
      background-color: rgba(144, 238, 144, 0.4);
    }
    .medium-score {
      background-color: rgba(255, 255, 153, 0.4);
    }
    .low-score {
      background-color: rgba(255, 182, 193, 0.4);
    }

    #scoreFilterContainer {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin: 1rem 0;
    }

    .download-container {
      display: inline-block;
      position: relative;
    }

    .download-dropdown {
      display: none;
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      min-width: 160px;
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.3);
      z-index: 9999;
      top: 100%;
      left: 0;
      overflow: hidden;
    }

    .download-dropdown a {
      color: #333;
      padding: 12px 16px;
      text-decoration: none;
      display: block;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.1);
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .download-dropdown a:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateX(4px);
    }

    .download-dropdown a:last-child {
      border-bottom: none;
    }

    /* Glass morphism for headings */
    h1, h2, h3, h4 {
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 12px 20px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 4px 16px rgba(31, 38, 135, 0.15);
      margin: 16px 0;
      display: inline-block;
    }
  </style>
</head>
<body>
  <h1>üè† Find Hidden Gems Near You!</h1>
  <h3>Senior Living Discovery Tool</h3>
  <p>Generated by <strong>myTech.Today</strong> ‚Äî <em>@mytech-today-now</em> on GitHub</p>

  <button type="button" onclick="document.getElementById('popup').style.display='flex'">How this works?</button>
  <div id="popup" class="popup">
    <div class="popup-content">
      <span class="close-btn" onclick="document.getElementById('popup').style.display='none'">‚úñ</span>
      <h2>üß† Under the Hood</h2>
      <p>This application uses the SheetJS library to parse uploaded spreadsheets in .ods, .xlsx, .xls, or .csv format. Each row is interpreted using flexible column matching for: Name/Facility Name, Address (or Street Number + Street Name), City/Town, State, and Zip/Zip Code.</p>
      <p>The app builds addresses from those columns and attempts web searches to identify useful context around your criteria. Due to browser CORS limitations, it uses fallback search methods and simulated results for demonstration.</p>
      <p><strong>Note:</strong> For production use, this would require a backend service or paid search API to perform real web searches.</p>
      <p>User-entered criteria are parsed into keywords. Each result summary is scored by matching those keywords, and the final score appears alongside the summary.</p>
      <p>The final table can be edited and downloaded in multiple formats (.xlsx, .xls, .csv, .ods) using a client-side file generator.</p>
      <code>Console logs events, parsing, and errors for debugging. Check browser console for detailed information.</code>
    </div>
  </div>

  <div class="glass-card">
    <h4>üìù Description</h4>
    <p>1. Drag-and-drop or upload your spreadsheet<br>
       2. Add filtering criteria (e.g., ‚Äúclose to nature‚Äù, ‚Äúless than $500‚Äù etc.)<br>
       3. Press Submit<br>
       4. Review results and export as .ODS</p>
  </div>

  <div class="glass-card">
    <label for="fileInput">Upload Spreadsheet:</label>
    <input type="file" id="fileInput" accept=".xlsx,.xls,.csv,.ods">
    <textarea id="criteria" rows="4" placeholder="e.g. Needs to be furnished, costs less than $500, accepts pets over 50 lbs">
accepts service animals above 50 lbs., Costs less than $500/month, Assisted or unassisted senior living, close to a hospital, gas station, and grocery store, needs to be furnished, in the state of Illinois, close to a nature area, fewer than 100 residents</textarea>
    <button type="button" onclick="processFile()">Submit</button>
    <div class="download-container">
      <button type="button" onclick="toggleDownloadDropdown()" class="download-btn">
        Download ‚ñº
      </button>
      <div id="downloadDropdown" class="download-dropdown">
        <a onclick="downloadFile('xlsx')">üìä Excel (.xlsx)</a>
        <a onclick="downloadFile('xls')">üìä Excel Legacy (.xls)</a>
        <a onclick="downloadFile('csv')">üìÑ CSV (.csv)</a>
        <a onclick="downloadFile('ods')">üìã OpenDocument (.ods)</a>
      </div>
    </div>
  </div>

  <div id="scoreFilterContainer" class="glass-card">
    <label for="scoreFilter">Min Score:</label>
    <input type="range" id="scoreFilter" min="0" max="10" value="0" step="1" onchange="filterByScore(this.value)">
    <span id="scoreDisplay">0</span>
  </div>

  <div id="outputTable" class="glass-card">
    <table id="results"></table>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script>
    let globalData = [];

    function logError(err) {
      console.error("[Error]", err);
    }

    function logEvent(msg) {
      console.log("[Event]", msg);
    }

    async function realSearchQuery(address, criteriaKeywords) {
      // Log the address being searched for debugging
      logEvent(`Searching for: ${address}`);

      const query = encodeURIComponent(`${address} ${criteriaKeywords.join(' ')}`);

      // Try multiple search approaches due to CORS limitations
      try {
        // First try: Use a CORS proxy
        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(`https://duckduckgo.com/html/?q=${query}`)}`;
        const res = await fetch(proxyUrl);
        const data = await res.json();

        if (data.contents) {
          // Simple text extraction from HTML response
          const text = data.contents.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
          const summary = text.substring(0, 500) + (text.length > 500 ? '...' : '');
          return summary || "No detailed results found";
        }
      } catch (err) {
        logError(`Search attempt 1 failed: ${err.message}`);
      }

      try {
        // Second try: Use JSONPlaceholder as a mock service for demonstration
        // In a real implementation, you'd use a proper search API or backend service
        const mockResponse = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        if (mockResponse.ok) {
          return `Mock search result for ${address}. In a production environment, this would contain real search results about senior living facilities, amenities, and services in this area.`;
        }
      } catch (err) {
        logError(`Search attempt 2 failed: ${err.message}`);
      }

      // Fallback: Return a simulated result based on criteria
      return `Simulated search result for ${address}. This location may offer ${criteriaKeywords.slice(0, 3).join(', ')} and other amenities. Real implementation would require a backend service or paid search API.`;
    }

    function scoreKeywords(text, keywords) {
      const lowerText = text.toLowerCase();
      let score = 0;
      keywords.forEach(k => {
        if (lowerText.includes(k.toLowerCase())) score++;
      });
      return score;
    }

    async function processFile() {
      const fileInput = document.getElementById('fileInput');
      const file = fileInput.files[0];
      const criteriaText = document.getElementById('criteria').value;
      if (!file) return alert("Please upload a file first.");

      const criteriaKeywords = criteriaText.split(',').map(c => c.trim()).filter(Boolean);

      const reader = new FileReader();
      reader.onload = async (e) => {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          const sheet = workbook.Sheets[sheetName];
          const json = XLSX.utils.sheet_to_json(sheet);

          globalData = [];

          // Debug: Log available columns
          if (json.length > 0) {
            logEvent(`Available columns: ${Object.keys(json[0]).join(', ')}`);
          }

          for (const row of json) {
            try {
              // More flexible column name matching
              const streetNumber = row['Street Number'] || row['street number'] || row['StreetNumber'] || row['Street_Number'] || '';
              const streetName = row['Street Name'] || row['street name'] || row['StreetName'] || row['Street_Name'] || '';
              const town = row['Town'] || row['town'] || row['City'] || row['city'] || '';
              const state = row['State'] || row['state'] || row['ST'] || row['st'] || '';
              const zip = row['Zip'] || row['zip'] || row['ZIP'] || row['Zipcode'] || row['zipcode'] || row['Zip Code'] || '';
              const name = row['Name'] || row['name'] || row['Facility Name'] || row['facility name'] || row['Facility ID'] || 'Unknown Facility';

              // Handle both split address fields and single address field
              let address;
              const fullAddress = row['Address'] || row['address'] || '';
              if (fullAddress) {
                // Use the full address field if available
                address = `${fullAddress}, ${town}, ${state} ${zip}`.trim();
              } else {
                // Fall back to constructing from separate fields
                address = `${streetNumber} ${streetName}, ${town}, ${state} ${zip}`.trim();
              }

              // Only search if we have a reasonable address
              if (town && state) {
                logEvent(`Processing: ${name} at ${address}`);
                const scrapedText = await realSearchQuery(address, criteriaKeywords);
                const matchScore = scoreKeywords(scrapedText, criteriaKeywords);
                globalData.push({
                  Name: name,
                  'Street Number': streetNumber,
                  'Street Name': streetName,
                  Address: fullAddress,
                  Town: town,
                  City: town, // Include both for compatibility
                  State: state,
                  Zip: zip,
                  'Zip Code': zip, // Include both for compatibility
                  ...row,
                  SearchSummary: scrapedText,
                  Score: matchScore
                });
              } else {
                logEvent(`Skipping row due to incomplete address data: ${JSON.stringify(row)}`);
                globalData.push({
                  ...row,
                  SearchSummary: "Incomplete address data",
                  Score: 0
                });
              }
            } catch (e) {
              logError(e);
              globalData.push({
                ...row,
                SearchSummary: "Error processing row",
                Score: 0
              });
            }
          }

          renderTable(globalData);
          logEvent("Spreadsheet processed and scored.");
        } catch (err) {
          logError(err);
          alert("Failed to process spreadsheet.");
        }
      };
      reader.readAsArrayBuffer(file);
    }

    function renderTable(data) {
      const table = document.getElementById('results');
      table.innerHTML = '';
      const headers = Object.keys(data[0] || {});
      const headerRow = document.createElement('tr');
      headers.forEach(h => {
        const th = document.createElement('th');
        th.innerText = h;
        headerRow.appendChild(th);
      });
      table.appendChild(headerRow);

      data.forEach(row => {
        const tr = document.createElement('tr');
        let score = parseInt(row['Score'], 10);
        if (score >= 5) tr.classList.add('high-score');
        else if (score >= 3) tr.classList.add('medium-score');
        else tr.classList.add('low-score');
        tr.dataset.score = score;

        headers.forEach(h => {
          const td = document.createElement('td');
          td.contentEditable = true;
          td.innerText = row[h] || '';
          tr.appendChild(td);
        });
        table.appendChild(tr);
      });
    }

    function filterByScore(minScore) {
      const rows = document.querySelectorAll('#results tr');
      document.getElementById('scoreDisplay').textContent = minScore;
      rows.forEach((row, index) => {
        if (index === 0) return; // header row
        const score = parseInt(row.dataset.score || '0', 10);
        row.style.display = score >= minScore ? '' : 'none';
      });
    }

    function toggleDownloadDropdown() {
      const dropdown = document.getElementById('downloadDropdown');
      dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
    }

    // Close dropdown when clicking outside
    window.onclick = function(event) {
      if (!event.target.matches('.download-btn')) {
        const dropdown = document.getElementById('downloadDropdown');
        if (dropdown.style.display === 'block') {
          dropdown.style.display = 'none';
        }
      }
    }

    function downloadFile(format) {
      try {
        if (!globalData || globalData.length === 0) {
          alert("No data to download. Please process a file first.");
          return;
        }

        const ws = XLSX.utils.json_to_sheet(globalData);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Sheet1");

        let filename = "enriched_senior_living_data";
        let fileExtension = format;

        // Handle different formats
        switch(format) {
          case 'xlsx':
            filename += '.xlsx';
            break;
          case 'xls':
            filename += '.xls';
            break;
          case 'csv':
            filename += '.csv';
            break;
          case 'ods':
            filename += '.ods';
            break;
          default:
            filename += '.xlsx';
            fileExtension = 'xlsx';
        }

        XLSX.writeFile(wb, filename);
        logEvent(`${fileExtension.toUpperCase()} file downloaded: ${filename}`);

        // Close dropdown after download
        document.getElementById('downloadDropdown').style.display = 'none';
      } catch (err) {
        logError(err);
        alert(`Failed to generate ${format.toUpperCase()} file.`);
      }
    }
  </script>
</body>
</html>
